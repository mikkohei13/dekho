<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ðŸŒ‘ Dekho</title>
  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" sizes="any">
  <link rel="stylesheet" href="{{ url_for('static', filename='styles/index.css') }}">
</head>
<body>
  <nav id="top-nav">
    <div class="brand">Dekho</div>
    <a class="scan-link" href="/scan">Scan music folder</a>
  </nav>

  <main id="app-shell">
    <aside id="tracks-panel">
      <header class="panel-header">
        <div class="tracks-filter">
          <input id="tracks-filter-input" type="text" placeholder="Filter tracks...">
          <details id="tracks-label-filter" class="tracks-label-filter">
            <summary id="tracks-label-filter-summary">Labels (0)</summary>
            <div class="tracks-label-filter-popover">
              <div id="tracks-label-filter-options" class="tracks-label-filter-options"></div>
            </div>
          </details>
          <button id="tracks-clear-filters-btn" type="button" aria-label="Clear filters" title="Clear filters">X</button>
          <span id="tracks-filter-count"></span>
        </div>
        <div id="tracks-selected-labels" class="tracks-selected-labels" hidden></div>
      </header>

      <section id="tracks-list">
        {% if tracks %}
          <ul class="track-items">
            {% for track in tracks %}
              <li
                class="track-item"
                data-track-id="{{ track.track_id }}"
                data-label-keys="{{ track.label_keys | join(',') }}"
                tabindex="0"
              >
                <div class="track-item-content">
                  <img
                    class="track-item-image"
                    src="/api/tracks/{{ track.track_id }}/image"
                    width="50"
                    height="50"
                    loading="lazy"
                  >
                  <div class="track-item-body">
                    <h2 class="track-title">
                      {{ track.display_title }}
                      {% if track.has_remote_tags %}
                        <span class="remote-tags-indicator">âœ¦</span>
                      {% endif %}
                    </h2>
                    <p class="track-id">{{ track.track_id }}</p>
                    <p class="track-meta track-item-labels" data-track-item-labels>
                      {% if track.labels %}
                        {{ track.labels | join(", ") }}
                      {% else %}
                        -
                      {% endif %}
                    </p>
                    <div class="track-meta-block">
                      <p class="track-meta" id="track-meta-title">
                        {{ track.title or "-" }}
                      </p>
                      {% if track.tags %}
                        <p class="track-meta" id="track-meta-tags">
                          {{ track.tags }}
                        </p>
                      {% endif %}
                    </div>
                  </div>
                </div>
              </li>
            {% endfor %}
          </ul>
        {% else %}
          <p class="empty-state">No tracks in the database under <code>./music</code> yet.</p>
        {% endif %}
      </section>
    </aside>

    <section id="content-panel">
      <div id="content-panel-body">
        <p class="empty-state">Select a track to view details.</p>
      </div>
    </section>
  </main>
  <header id="persistent-track-header" class="panel-header" hidden>
    <div class="persistent-track-title-row">
      <h2 id="persistent-track-title"></h2>
      <button id="show-playing-track-btn" type="button">Show</button>
    </div>
    <audio id="selected-track-player" controls preload="metadata">
      Your browser does not support audio playback.
    </audio>
  </header>
  <script id="tracks-label-catalog-data" type="application/json">{{ label_catalog | default([], true) | tojson }}</script>
  <script>
    const tracksLabelCatalogElement = document.getElementById("tracks-label-catalog-data");
    let tracksLabelCatalog = [];
    if (tracksLabelCatalogElement instanceof HTMLScriptElement) {
      try {
        const parsedCatalog = JSON.parse(tracksLabelCatalogElement.textContent || "[]");
        if (Array.isArray(parsedCatalog)) {
          tracksLabelCatalog = parsedCatalog;
        }
      } catch (error) {
        tracksLabelCatalog = [];
      }
    }
    const trackItems = Array.from(document.querySelectorAll(".track-item"));
    const tracksFilterInput = document.getElementById("tracks-filter-input");
    const tracksFilterCount = document.getElementById("tracks-filter-count");
    const tracksLabelFilter = document.getElementById("tracks-label-filter");
    const tracksLabelFilterSummary = document.getElementById("tracks-label-filter-summary");
    const tracksLabelFilterOptions = document.getElementById("tracks-label-filter-options");
    const tracksSelectedLabels = document.getElementById("tracks-selected-labels");
    const tracksClearFiltersButton = document.getElementById("tracks-clear-filters-btn");
    const contentPanel = document.getElementById("content-panel");
    const contentPanelBody = document.getElementById("content-panel-body");
    const persistentTrackHeader = document.getElementById("persistent-track-header");
    const persistentTrackTitle = document.getElementById("persistent-track-title");
    const selectedTrackPlayer = document.getElementById("selected-track-player");
    const showPlayingTrackButton = document.getElementById("show-playing-track-btn");
    const selectedTrackFilterLabelKeys = new Set();
    const trackLabelByKey = new Map();
    let activeTrackId = null;
    let activeTrackData = null;
    let hasUnsavedUserDataChanges = false;

    if (Array.isArray(tracksLabelCatalog)) {
      tracksLabelCatalog.forEach((group) => {
        const labels = Array.isArray(group?.labels) ? group.labels : [];
        labels.forEach((entry) => {
          if (!entry || typeof entry !== "object") {
            return;
          }
          const key = typeof entry.key === "string" ? entry.key : "";
          const label = typeof entry.label === "string" ? entry.label : "";
          if (!key || !label || trackLabelByKey.has(key)) {
            return;
          }
          trackLabelByKey.set(key, label);
        });
      });
    }

    function escapeHtml(value) {
      return String(value ?? "").replace(/[&<>"']/g, (char) => (
        {"&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"}[char]
      ));
    }

    function getDisplayTitle(data) {
      return data.title_new || data.title || "Unknown";
    }

    function hasRemoteTags(tags) {
      return tags !== null && tags !== undefined && String(tags).trim() !== "";
    }

    function remoteTagsIndicatorHtml() {
      return '<span class="remote-tags-indicator">âœ¦</span>';
    }

    function updateTracksFilterCount() {
      if (!(tracksFilterCount instanceof HTMLElement)) {
        return;
      }
      const total = trackItems.length;
      const matched = trackItems.filter((item) => !item.hidden).length;
      tracksFilterCount.textContent = `${matched}/${total} tracks`;
    }

    function parseLabelKeys(labelKeysValue) {
      return String(labelKeysValue ?? "")
        .split(",")
        .map((value) => value.trim())
        .filter(Boolean);
    }

    function getTrackItemLabelKeys(item) {
      return new Set(parseLabelKeys(item.dataset.labelKeys));
    }

    function updateTrackItemLabels(trackId, labelKeys) {
      const trackItem = document.querySelector(`.track-item[data-track-id="${CSS.escape(trackId)}"]`);
      if (!(trackItem instanceof HTMLElement)) {
        return;
      }

      const normalizedKeys = Array.isArray(labelKeys)
        ? labelKeys
          .filter((key) => typeof key === "string" && key)
          .map((key) => key.trim())
          .filter(Boolean)
        : [];
      trackItem.dataset.labelKeys = normalizedKeys.join(",");

      const labelsElement = trackItem.querySelector("[data-track-item-labels]");
      if (!(labelsElement instanceof HTMLElement)) {
        return;
      }

      const visibleLabels = normalizedKeys
        .map((key) => trackLabelByKey.get(key) || key)
        .join(", ");
      labelsElement.textContent = visibleLabels || "-";
    }

    function renderTrackLabelFilterOptions() {
      if (!(tracksLabelFilterOptions instanceof HTMLElement)) {
        return;
      }
      if (!Array.isArray(tracksLabelCatalog) || tracksLabelCatalog.length === 0) {
        tracksLabelFilterOptions.innerHTML = '<p class="empty-state">No labels configured.</p>';
        return;
      }

      const categories = [];
      tracksLabelCatalog.forEach((group) => {
        const categoryName = typeof group?.display_name === "string" && group.display_name
          ? group.display_name
          : (typeof group?.category === "string" ? group.category : "");
        const labels = Array.isArray(group?.labels) ? group.labels : [];
        if (!categoryName || labels.length === 0) {
          return;
        }
        const options = [];
        labels.forEach((labelEntry) => {
          if (!labelEntry || typeof labelEntry !== "object") {
            return;
          }
          const key = typeof labelEntry.key === "string" ? labelEntry.key : "";
          const label = typeof labelEntry.label === "string" ? labelEntry.label : "";
          if (!key || !label) {
            return;
          }
          options.push({ key, label, categoryName });
        });
        if (options.length > 0) {
          categories.push({ categoryName, options });
        }
      });

      tracksLabelFilterOptions.innerHTML = categories.map(({ categoryName, options }) => {
        const optionsHtml = options.map(({ key, label }) => {
          const inputId = `tracks-filter-label-${domSafeValue(key)}`;
          const checked = selectedTrackFilterLabelKeys.has(key) ? " checked" : "";
          return `
            <label for="${escapeHtml(inputId)}" class="tracks-filter-option">
              <input
                id="${escapeHtml(inputId)}"
                class="tracks-filter-option-input"
                type="checkbox"
                data-label-key="${escapeHtml(key)}"${checked}
              >
              <span>${escapeHtml(label)}</span>
            </label>
          `;
        }).join("");

        return `
          <section class="tracks-filter-category">
            <h4 class="tracks-filter-category-heading">${escapeHtml(categoryName)}</h4>
            <div class="tracks-filter-category-options">${optionsHtml}</div>
          </section>
        `;
      }).join("");
    }

    function updateTracksFilterSummary() {
      if (tracksLabelFilterSummary instanceof HTMLElement) {
        tracksLabelFilterSummary.textContent = `Labels (${selectedTrackFilterLabelKeys.size})`;
      }

      if (tracksSelectedLabels instanceof HTMLElement) {
        const selectedLabels = Array.from(selectedTrackFilterLabelKeys)
          .map((key) => trackLabelByKey.get(key) || key);
        if (selectedLabels.length === 0) {
          tracksSelectedLabels.hidden = true;
          tracksSelectedLabels.textContent = "";
        } else {
          const maxVisible = 8;
          const visibleLabels = selectedLabels.slice(0, maxVisible).join(", ");
          const moreCount = selectedLabels.length - maxVisible;
          tracksSelectedLabels.hidden = false;
          tracksSelectedLabels.textContent = moreCount > 0
            ? `Selected: ${visibleLabels} (+${moreCount})`
            : `Selected: ${visibleLabels}`;
        }
      }

      if (tracksClearFiltersButton instanceof HTMLButtonElement) {
        const hasTextQuery = tracksFilterInput instanceof HTMLInputElement && tracksFilterInput.value.trim() !== "";
        tracksClearFiltersButton.disabled = !hasTextQuery && selectedTrackFilterLabelKeys.size === 0;
      }
    }

    function applyTracksFilter() {
      const query = String(tracksFilterInput instanceof HTMLInputElement ? tracksFilterInput.value : "")
        .trim()
        .toLocaleLowerCase();
      trackItems.forEach((item) => {
        const haystack = (item.textContent || "").toLocaleLowerCase();
        const textMatches = query ? haystack.includes(query) : true;
        const trackLabelKeys = getTrackItemLabelKeys(item);
        const labelsMatch = Array.from(selectedTrackFilterLabelKeys).every(
          (labelKey) => trackLabelKeys.has(labelKey)
        );
        item.hidden = !(textMatches && labelsMatch);
      });
      updateTracksFilterCount();
      updateTracksFilterSummary();
    }

    function domSafeValue(value) {
      return String(value ?? "").replace(/[^a-zA-Z0-9_-]/g, "-");
    }

    function getTrackImageSrc(trackId) {
      const id = String(trackId ?? "").trim();
      if (!id) {
        return "";
      }
      return `/api/tracks/${encodeURIComponent(id)}/image`;
    }

    function getTrackSpectrogramSrc(trackId) {
      const id = String(trackId ?? "").trim();
      if (!id) {
        return "";
      }
      return `/api/tracks/${encodeURIComponent(id)}/spectrogram`;
    }

    function renderLabelGroups(labelCatalog, selectedLabels) {
      if (!Array.isArray(labelCatalog) || labelCatalog.length === 0) {
        return '<p class="empty-state">No labels configured.</p>';
      }

      const selectedKeys = new Set(Array.isArray(selectedLabels) ? selectedLabels : []);

      return labelCatalog.map((group) => {
        const category = typeof group.category === "string" ? group.category : "";
        const displayName = typeof group.display_name === "string" ? group.display_name : category;
        const labels = Array.isArray(group.labels) ? group.labels : [];
        if (!category || labels.length === 0) {
          return "";
        }

        const optionsHtml = labels
          .map((labelEntry) => {
            if (!labelEntry || typeof labelEntry !== "object") {
              return "";
            }
            const labelKey = typeof labelEntry.key === "string" ? labelEntry.key : "";
            const label = typeof labelEntry.label === "string" ? labelEntry.label : "";
            if (!labelKey || !label) {
              return "";
            }
            const inputId = `track-label-${domSafeValue(labelKey)}`;
            const checked = selectedKeys.has(labelKey) ? " checked" : "";
            return `
              <label for="${escapeHtml(inputId)}" class="track-label-option">
                <input
                  id="${escapeHtml(inputId)}"
                  class="track-label-input"
                  type="checkbox"
                  data-label-key="${escapeHtml(labelKey)}"${checked}
                >
                <span>${escapeHtml(label)}</span>
              </label>
            `;
          })
          .join("");

        return `
          <fieldset class="track-label-category ${domSafeValue(displayName)}">
            <legend>${escapeHtml(displayName)}</legend>
            <div class="track-label-options">
              ${optionsHtml}
            </div>
          </fieldset>
        `;
      }).join("");
    }

    function updateTrackListTitle(trackId, data) {
      const trackItem = document.querySelector(`.track-item[data-track-id="${CSS.escape(trackId)}"]`);
      if (!trackItem) {
        return;
      }
      const titleElement = trackItem.querySelector(".track-title");
      if (!titleElement) {
        return;
      }
      const displayTitle = getDisplayTitle(data);
      titleElement.innerHTML = `${escapeHtml(displayTitle)}${hasRemoteTags(data.tags) ? remoteTagsIndicatorHtml() : ""}`;
      applyTracksFilter();
    }

    function updatePersistentTrackHeader(data) {
      if (
        !(persistentTrackHeader instanceof HTMLElement) ||
        !(persistentTrackTitle instanceof HTMLElement) ||
        !(selectedTrackPlayer instanceof HTMLAudioElement)
      ) {
        return;
      }

      const trackId = data.track_id ?? "";
      if (!trackId) {
        persistentTrackHeader.hidden = true;
        if (showPlayingTrackButton instanceof HTMLButtonElement) {
          showPlayingTrackButton.disabled = true;
        }
        delete selectedTrackPlayer.dataset.trackId;
        selectedTrackPlayer.removeAttribute("src");
        selectedTrackPlayer.load();
        return;
      }

      const displayTitle = getDisplayTitle(data) || "Untitled Track";
      const nextSrc = `/api/tracks/${encodeURIComponent(trackId)}/audio`;
      const currentSrc = selectedTrackPlayer.getAttribute("src") || "";

      persistentTrackHeader.hidden = false;
      selectedTrackPlayer.dataset.trackId = trackId;
      if (showPlayingTrackButton instanceof HTMLButtonElement) {
        showPlayingTrackButton.disabled = false;
      }
      persistentTrackTitle.textContent = displayTitle;

      // Keep playback uninterrupted when form save rerenders the details for same track.
      if (currentSrc !== nextSrc) {
        selectedTrackPlayer.setAttribute("src", nextSrc);
        selectedTrackPlayer.load();
      }
    }

    function updatePersistentTrackTitleIfPlaying(data) {
      if (
        !(persistentTrackTitle instanceof HTMLElement) ||
        !(selectedTrackPlayer instanceof HTMLAudioElement)
      ) {
        return;
      }
      const trackId = data.track_id ?? "";
      const playingTrackId = selectedTrackPlayer.dataset.trackId ?? "";
      if (!trackId || playingTrackId !== trackId) {
        return;
      }
      const displayTitle = getDisplayTitle(data) || "Untitled Track";
      persistentTrackTitle.textContent = displayTitle;
    }

    function showPlayingTrackInContentPanel() {
      const trackId = selectedTrackPlayer instanceof HTMLAudioElement
        ? (selectedTrackPlayer.dataset.trackId ?? "")
        : "";
      if (!trackId) {
        return;
      }
      const trackItem = document.querySelector(`.track-item[data-track-id="${CSS.escape(trackId)}"]`);
      if (!(trackItem instanceof HTMLElement)) {
        return;
      }
      if (hasUnsavedUserDataChanges && activeTrackId && activeTrackId !== trackId) {
        const shouldContinue = window.confirm("You have unsaved changes. Leave this track without saving?");
        if (!shouldContinue) {
          return;
        }
      }
      loadTrackDetails(trackId, trackItem);
    }

    function setTrackUserDataSaveStatus(statusText) {
      const saveStatus = document.getElementById("track-user-data-save-status");
      if (!(saveStatus instanceof HTMLElement)) {
        return;
      }
      saveStatus.textContent = statusText;
    }

    function markTrackUserDataSaved() {
      hasUnsavedUserDataChanges = false;
      setTrackUserDataSaveStatus("saved");
    }

    function markTrackUserDataUnsaved() {
      hasUnsavedUserDataChanges = true;
      setTrackUserDataSaveStatus("unsaved changes");
    }

    function renderDetails(data) {
      const title = data.title ?? "";
      const titleNew = data.title_new ?? "";
      const notes = data.notes ?? "";
      const trackId = data.track_id ?? "";
      const url = data.url ?? "";
      const filepath = data.filepath ?? "";
      const duration = data.duration ?? "";
      const dateCreated = data.date_created ?? "";
      const tags = data.tags ?? "";
      const negativeTags = data.negative_tags ?? "";
      const hasCoverClipId = Boolean(data.has_cover_clip_id);
      const majorModelVersion = data.major_model_version ?? "";
      const modelName = data.model_name ?? "";
      const personaName = data.persona_name ?? "";
      const prompt = data.prompt ?? "";
      const labels = Array.isArray(data.labels) ? data.labels : [];
      const labelCatalog = Array.isArray(data.label_catalog) ? data.label_catalog : [];
      const displayTitle = getDisplayTitle(data) || "Untitled Track";

      if (!(contentPanelBody instanceof HTMLElement)) {
        return;
      }

      contentPanelBody.innerHTML = `
        <section id="track-info">
          <header class="panel-header track-info-header">
            <h2>
              ${escapeHtml(displayTitle)}${hasRemoteTags(tags) ? remoteTagsIndicatorHtml() : ""}
            </h2>
            <button id="play-current-track-btn" type="button">Play</button>
          </header>
          <div class="track-form">
            <form id="track-user-data-form">
              <label for="title-new-input">title_new</label>
              <input id="title-new-input" name="title_new" type="text" value="${escapeHtml(titleNew)}">
              <label for="notes-input">notes</label>
              <textarea id="notes-input" name="notes" rows="4">${escapeHtml(notes)}</textarea>
              <div class="track-labels">
                <div class="track-labels-groups">
                  ${renderLabelGroups(labelCatalog, labels)}
                </div>
              </div>
              <div class="track-user-data-actions">
                <button id="save-track-user-data-btn" type="button">Save</button>
                <span id="track-user-data-save-status" class="track-user-data-save-status">saved</span>
                <span id="track-user-data-error" class="track-user-data-error"></span>
              </div>
            </form>
          </div>
          <div class="track-details">
            <img
              class="track-details-image"
              src="${escapeHtml(getTrackImageSrc(trackId))}"
              width="200"
              height="200"
            >
            <img
              class="track-details-spectrogram"
              src="${escapeHtml(getTrackSpectrogramSrc(trackId))}"
              alt="Spectrogram"
              loading="lazy"
              onerror="this.hidden = true;"
            >
            <p id="track-info-title">${escapeHtml(title || "-")}</p>
            <p id="track-info-id">${escapeHtml(trackId)}</p>
            <p id="track-info-url">${url ? `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(url)}</a>` : "-"}<p>
            <p id="track-info-filepath">${escapeHtml(filepath)}</p>
            <p id="track-info-duration">${escapeHtml(duration)}</p>
            <p id="track-info-date-created">${escapeHtml(dateCreated)}</p>
          </div>
          <div class="track-moredetails">
            <div class="remote-actions">
              <button id="get-remote-data-btn" type="button">Get data from Suno</button>
              <span id="remote-data-error" class="remote-data-error"></span>
            </div>
            <h4>Tags</h4>
            <div id="track-info-tags">${escapeHtml(tags || "-")}</div>
            <h4>Negative Tags</h4>
            <div id="track-info-negative-tags">${escapeHtml(negativeTags || "-")}</div>
            <h4>Has Cover Clip ID</h4>
            <div id="track-info-has-cover-clip-id">${hasCoverClipId ? "True" : "False"}</div>
            <h4>Major Model Version</h4>
            <div id="track-info-major-model-version">${escapeHtml(majorModelVersion || "-")}</div>
            <h4>Model Name</h4>
            <div id="track-info-model-name">${escapeHtml(modelName || "-")}</div>
            <h4>Persona Name</h4>
            <div id="track-info-persona-name">${escapeHtml(personaName || "-")}</div>
            <h4>Lyrics Prompt</h4>
            <div id="track-info-prompt">${escapeHtml(prompt || "-")}</div>
          </div>
        </section>
      `;
      activeTrackData = data;
      markTrackUserDataSaved();
    }

    async function loadTrackDetails(trackId, item) {
      trackItems.forEach((trackItem) => trackItem.classList.remove("is-active"));
      item.classList.add("is-active");
      activeTrackId = trackId;
      activeTrackData = null;
      if (contentPanelBody instanceof HTMLElement) {
        contentPanelBody.innerHTML = '<p class="empty-state">Loading track details...</p>';
      }

      try {
        const response = await fetch(`/api/tracks/${encodeURIComponent(trackId)}`);
        if (!response.ok) {
          throw new Error("Unable to load track details.");
        }
        const data = await response.json();
        updateTrackListTitle(trackId, data);
        updateTrackItemLabels(trackId, data.labels);
        renderDetails(data);
      } catch (error) {
        if (contentPanelBody instanceof HTMLElement) {
          contentPanelBody.innerHTML = `<p class="empty-state">${escapeHtml(error.message || "Unable to load track details.")}</p>`;
        }
      }
    }

    async function fetchRemoteData(trackId) {
      const button = document.getElementById("get-remote-data-btn");
      const error = document.getElementById("remote-data-error");
      if (!button || !error) {
        return;
      }

      error.textContent = "";
      button.disabled = true;
      button.textContent = "Fetching...";

      try {
        const response = await fetch(`/api/tracks/${encodeURIComponent(trackId)}/remote-data`, {
          method: "POST",
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || "Failed to fetch data from Suno.");
        }
        updateTrackListTitle(trackId, payload);
        updateTrackItemLabels(trackId, payload.labels);
        updatePersistentTrackTitleIfPlaying(payload);
        renderDetails(payload);
      } catch (fetchError) {
        error.textContent = fetchError.message || "Failed to fetch data from Suno.";
      } finally {
        const nextButton = document.getElementById("get-remote-data-btn");
        if (nextButton) {
          nextButton.disabled = false;
          nextButton.textContent = "Get data from Suno";
        }
      }
    }

    async function saveUserData(trackId) {
      const button = document.getElementById("save-track-user-data-btn");
      const error = document.getElementById("track-user-data-error");
      const titleInput = document.getElementById("title-new-input");
      const notesInput = document.getElementById("notes-input");
      const selectedLabelInputs = contentPanelBody
        ? contentPanelBody.querySelectorAll(".track-label-input:checked")
        : [];
      if (
        !button ||
        !error ||
        !(titleInput instanceof HTMLInputElement) ||
        !(notesInput instanceof HTMLTextAreaElement)
      ) {
        return;
      }

      error.textContent = "";
      button.disabled = true;
      button.textContent = "Saving...";

      const labels = [];
      selectedLabelInputs.forEach((input) => {
        if (!(input instanceof HTMLInputElement)) {
          return;
        }
        const labelKey = input.dataset.labelKey;
        if (typeof labelKey !== "string" || !labelKey) {
          return;
        }
        labels.push(labelKey);
      });

      try {
        const response = await fetch(`/api/tracks/${encodeURIComponent(trackId)}/user-data`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            title_new: titleInput.value,
            notes: notesInput.value,
            labels,
          }),
        });
        const payload = await response.json();
        if (!response.ok) {
          throw new Error(payload.error || "Failed to save track data.");
        }
        updateTrackListTitle(trackId, payload);
        updateTrackItemLabels(trackId, payload.labels);
        updatePersistentTrackTitleIfPlaying(payload);
        renderDetails(payload);
      } catch (saveError) {
        error.textContent = saveError.message || "Failed to save track data.";
      } finally {
        const nextButton = document.getElementById("save-track-user-data-btn");
        if (nextButton) {
          nextButton.disabled = false;
          nextButton.textContent = "Save";
        }
      }
    }

    trackItems.forEach((item) => {
      const trackId = item.dataset.trackId;
      if (!trackId) {
        return;
      }

      item.addEventListener("click", () => {
        if (hasUnsavedUserDataChanges && activeTrackId && activeTrackId !== trackId) {
          const shouldContinue = window.confirm("You have unsaved changes. Leave this track without saving?");
          if (!shouldContinue) {
            return;
          }
        }
        loadTrackDetails(trackId, item);
      });
      item.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          if (hasUnsavedUserDataChanges && activeTrackId && activeTrackId !== trackId) {
            const shouldContinue = window.confirm("You have unsaved changes. Leave this track without saving?");
            if (!shouldContinue) {
              return;
            }
          }
          loadTrackDetails(trackId, item);
        }
      });
    });

    if (tracksFilterInput instanceof HTMLInputElement) {
      tracksFilterInput.addEventListener("input", applyTracksFilter);
    }
    if (tracksLabelFilterOptions instanceof HTMLElement) {
      tracksLabelFilterOptions.addEventListener("change", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement) || !target.classList.contains("tracks-filter-option-input")) {
          return;
        }
        const labelKey = target.dataset.labelKey;
        if (!labelKey) {
          return;
        }
        if (target.checked) {
          selectedTrackFilterLabelKeys.add(labelKey);
        } else {
          selectedTrackFilterLabelKeys.delete(labelKey);
        }
        applyTracksFilter();
      });
    }
    if (tracksClearFiltersButton instanceof HTMLButtonElement) {
      tracksClearFiltersButton.addEventListener("click", () => {
        selectedTrackFilterLabelKeys.clear();
        if (tracksFilterInput instanceof HTMLInputElement) {
          tracksFilterInput.value = "";
        }
        if (tracksLabelFilter instanceof HTMLDetailsElement) {
          tracksLabelFilter.open = false;
        }
        renderTrackLabelFilterOptions();
        applyTracksFilter();
      });
    }
    if (tracksLabelFilter instanceof HTMLDetailsElement) {
      tracksLabelFilter.addEventListener("toggle", () => {
        if (tracksLabelFilter.open) {
          renderTrackLabelFilterOptions();
        }
      });
    }
    renderTrackLabelFilterOptions();
    applyTracksFilter();
    if (showPlayingTrackButton instanceof HTMLButtonElement) {
      showPlayingTrackButton.disabled = true;
      showPlayingTrackButton.addEventListener("click", showPlayingTrackInContentPanel);
    }

    contentPanel.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      if (target.id === "get-remote-data-btn" && activeTrackId) {
        if (hasUnsavedUserDataChanges) {
          const shouldContinue = window.confirm("You have unsaved changes. Continue without saving?");
          if (!shouldContinue) {
            return;
          }
        }
        fetchRemoteData(activeTrackId);
      }
      if (target.id === "save-track-user-data-btn" && activeTrackId) {
        saveUserData(activeTrackId);
      }
      if (target.id === "play-current-track-btn" && activeTrackData) {
        updatePersistentTrackHeader(activeTrackData);
        const playAttempt = selectedTrackPlayer.play();
        if (playAttempt && typeof playAttempt.catch === "function") {
          playAttempt.catch(() => {});
        }
      }
    });

    contentPanel.addEventListener("input", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      if (target.closest("#track-user-data-form")) {
        markTrackUserDataUnsaved();
      }
    });

    contentPanel.addEventListener("change", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      if (target.closest("#track-user-data-form")) {
        markTrackUserDataUnsaved();
      }
    });
  </script>
</body>
</html>
